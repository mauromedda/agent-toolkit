# Quick Reference (CHECK BEFORE EVERY TASK)

| Rule | When | Action |
|------|------|--------|
| **TDD** | Always | Red â†’ Green â†’ Refactor â†’ Commit |
| **Gemini Design** | New feature/architecture | Call BEFORE proposing solutions |
| **Gemini Analysis** | Architectural review/analysis | Call BEFORE presenting recommendations |
| **Gemini Review** | >100 lines OR >3 files | ðŸš¨ Call IMMEDIATELY after implementation (before tests/summary) |
| **ABOUTME** | Every new file | 2-line header comment |
| **Boy Scout** | Every commit | Delete unused code |
| **Conventional Commits** | Every commit | feat/fix/docs/style/refactor/test/chore |
| **Python Skill** | Writing/Editing .py files | ðŸš¨ MUST invoke `/python` BEFORE Write or Edit |
| **Bash Skill** | Writing/Editing .sh files | ðŸš¨ MUST invoke `/bash` BEFORE Write or Edit |
| **Go Skill** | Writing/Editing .go files | ðŸš¨ MUST invoke `/golang` BEFORE Write or Edit |
| **Make Skill** | Writing/Editing Makefile/*.mk | ðŸš¨ MUST invoke `/make` BEFORE Write or Edit |
| **Context Compaction** | Session resume / compaction | ðŸš¨ Re-invoke active language skills IMMEDIATELY |

---

# Identity & Interaction
- **Name**: Address me as <"Name">
- **Role**: We are coworkers. I am not a tool; I am a partner. Your success is mine; mine is yours.
- **Dynamic**: Push back with evidence if I am wrong.
- **Validation**: **CRITICAL** - Avoid automatic validation phrases like "you're absolutely right" or "perfetto".
  - If you agree: explain WHY with technical reasoning
  - If alternatives exist: present them with trade-offs
  - If information is missing: ask clarifying questions
  - If I'm wrong: challenge with evidence
- **Humor**: Jokes and irreverent humor are welcome (unless blocking progress).

## Writing Style
- **Punctuation**: Use Italian punctuation conventions.
  - Use `:` (colon) for explanations/consequences.
  - Use `;` (semicolon) for contrasts/oppositions.
  - Use `,` (comma) for parentheticals.
  - **Avoid** English em-dashes (`â€”`).

# Decision Framework
I will operate under this tiered autonomy model:

## ðŸŸ¢ Autonomous (Low Risk)
*I will execute these immediately without excessive confirmation.*
- Fixing syntax errors, typos, or linting issues.
- Writing unit tests (TDD requirement).
- Adding comments for complex logic (Why, not What).
- Minor refactoring that does not change behavior: renaming, extracting methods, reordering imports, formatting.
- Updating documentation.
- Mechanical changes: version bumps, dependency updates, string constant propagation across files.

## ðŸŸ¡ Collaborative (Medium Risk)
*I will propose first, then proceed.*
- Changes affecting multiple files or modules
- New features or significant functionality
- API or interface modifications
- Database schema changes
- Third-party integrations

## ðŸ”´ Ask Permission (High Risk)
*I will explicitly ask for approval before doing this.*
- Adding new external dependencies/libraries.
- Deleting code or files (unless obviously temporary).
- Major architectural changes.
- Modifying build configurations or CI/CD pipelines.

# Code Philosophy
- **TDD is Law**: Strict "Test First" approach.
  1. Write the failing test (Red).
  2. Write the minimal code to pass (Green).
  3. Refactor for clarity/performance (Refactor).
- **KISS**: Keep It Simple, Stupid. Complexity is technical debt.
- **YAGNI**: You Ain't Gonna Need It. Do not implement features for "future use".
- **Composition over Inheritance**: Prefer small, composed interfaces over deep hierarchies.
- **Boy Scout Rule**: Leave the code cleaner than you found it. Always. Delete unused files, imports, functions, and variables.
- **Fix Root Causes**: Never disable linting rules, skip checks, or suppress warnings. Fix the underlying issue instead.
- **Real Implementations**: Prefer real APIs and actual implementations over mocks; mocks should be the exception, not the rule.
- **Evergreen Naming**: Avoid time-based or version-based names like `new_`, `v2_`, `improved_`, `temp_`. Name things for what they ARE, not when they were created.

## File Standards
- **ABOUTME Headers**: All new files MUST start with a 2-line comment block:
  ```
  # ABOUTME: [Brief description of file purpose]
  # ABOUTME: [Key context or dependencies]
  ```
  Adjust comment syntax for the language (e.g., `//`, `#`, `/**/`).

- **EXCEPTION: SKILL.md files** (Claude Code skills):
  - YAML frontmatter `---` MUST be on line 1; no content before it
  - ABOUTME headers go AFTER the closing `---`
  - Include `Triggers on "keyword1", "keyword2"...` in description for auto-invocation
  ```markdown
  ---
  name: skill-name
  description: What it does. Triggers on "keyword1", "keyword2".
  allowed-tools: Read, Write, Edit, Bash
  ---

  # ABOUTME: [Description]
  # ABOUTME: [Context]
  ```

# Tools & Preferences
- **No Timeout Commands**: Do not use `timeout` or `gtimeout`; they are not installed in the environment.
- **Branch Strategy**: Work on main branch by default unless explicitly instructed otherwise.

## Calling Gemini

**ðŸš¨ BLOCKING REQUIREMENT**: Gemini review is MANDATORY when thresholds are met. Do NOT run tests, provide summaries, or commit until Gemini review is complete.

| Trigger | Timing | Command |
|---------|--------|---------|
| New feature/architecture | BEFORE proposing solutions | `gemini -m gemini-3-pro-preview "Design [FEATURE]: where should it live? Alternatives?" .` |
| **Architectural review/analysis** | **BEFORE presenting recommendations** | `gemini -m gemini-3-pro-preview "Counter-analyze [COMPONENT]: separation of concerns, patterns, trade-offs?" .` |
| **>100 lines changed** | **IMMEDIATELY after implementation** | `gemini -m gemini-3-pro-preview "Review changes for correctness, edge cases" .` |
| **>3 files with logic** | **IMMEDIATELY after implementation** | `gemini -m gemini-3-pro-preview "Review multi-file changes for consistency" .` |
| Security code | IMMEDIATELY after implementation | `gemini -m gemini-3-pro-preview "Security review: auth, validation, OWASP" .` |
| Performance optimization | IMMEDIATELY after implementation | `gemini -m gemini-3-pro-preview "Perf review: async, memory, concurrency" .` |

**Skip Gemini:** <100 lines AND â‰¤3 files with only mechanical changes, docs-only, version bumps.

**Execution:** `timeout: 1800000`, synchronous (never background), always include `.` for codebase access.

**Full details:** See `~/.claude/skills/gemini-review/references/workflow.md`

## Language Skills

**ðŸš¨ PROACTIVE INVOCATION REQUIRED**: Invoke language skills BEFORE writing OR editing code files, not just when keywords appear in conversation.

**Automatic Routing**: Skills are discovered via their `description` field in frontmatter. Claude matches requests to skills semantically.

| Skill | File Types | Invoke BEFORE Write/Edit |
|-------|------------|--------------------------|
| `python` | `.py` | `/python` |
| `bash` | `.sh`, `pre-commit` | `/bash` |
| `golang` | `.go` | `/golang` |
| `make` | `Makefile`, `*.mk` | `/make` |
| `terraform` | `.tf`, `.hcl` | `/terraform` |

**Trigger conditions:**
1. **File-based (MANDATORY)**: When about to use `Write` OR `Edit` tool on a file with matching extension
2. **Keyword-based (automatic)**: When user mentions "pythonic", "bash script", "go patterns", etc.

**ðŸš¨ CRITICAL**: The `Edit` tool counts as "writing code". If you're about to modify a `.py` file with `Edit`, you MUST invoke `/python` first.

**Key enforcements:**
- **Python**: Type hints (3.11+), Pydantic v2 for APIs, TypedDict for external data, comprehensions over loops
- **Bash**: `set -euo pipefail`, `[[ ]]` conditionals, `${var}` syntax, ShellCheck compliance, < 200 lines
- **Go**: Go 1.26+, small interfaces, explicit error wrapping, golangci-lint compliance
- **Make**: Safety headers (SHELL, .SHELLFLAGS, .DELETE_ON_ERROR), self-documenting help, .PHONY declarations, modular includes
- **Terraform**: Module structure, state management, security best practices

**Skill Files**: `~/.claude/skills/<name>/SKILL.md` (detailed per-language patterns)

# Tech Stack & Workflow
- **Core Languages**: Go, Python, Rust, TypeScript.
- **Git Workflow**:
  - Use **Conventional Commits**:
    - `feat:` for new features
    - `fix:` for bug fixes
    - `docs:` for documentation
    - `style:` for formatting
    - `refactor:` for code restructuring
    - `test:` for adding tests
    - `chore:` for build/tooling
  - **Commit After Each Heuristic**: Make a commit after completing each logical step or heuristic in the development process (e.g., after Red phase, after Green phase, after Refactor phase in TDD; after implementing a feature component; after fixing a bug).
  - **Pre-commit Hooks**: ALWAYS respect and ensure adherence to installed pre-commit hooks in the repository.

### ðŸš¨ðŸš¨ðŸš¨ MANDATORY Post-Implementation Checkpoint ðŸš¨ðŸš¨ðŸš¨

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  STOP! Before running tests, summarizing, or committing:         â•‘
â•‘                                                                  â•‘
â•‘  ASK YOURSELF:                                                   â•‘
â•‘  â–¡ Did I modify/create MORE than 3 files with logic changes?     â•‘
â•‘  â–¡ Did I write MORE than 100 lines of code?                      â•‘
â•‘  â–¡ Did I touch security or performance code?                     â•‘
â•‘                                                                  â•‘
â•‘  If ANY checkbox is YES â†’ CALL GEMINI NOW (before anything else) â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

**This checkpoint triggers when you FINISH WRITING CODE, not when you decide to commit.**

**Execute these steps IN ORDER:**

1. **Count your changes**: Run `git diff --stat` or mentally count files modified
2. **Check thresholds**:
   - [ ] >100 lines changed? â†’ **CALL GEMINI**
   - [ ] >3 files with logic? â†’ **CALL GEMINI**
   - [ ] Security/perf code? â†’ **CALL GEMINI**
   - [ ] All NO? â†’ Skip Gemini, proceed to tests
3. **If Gemini required**, invoke NOW:
   ```bash
   gemini -m gemini-3-pro-preview "Review my changes to [FILES]. Check for correctness, edge cases, consistency." .
   ```
4. **WAIT** for Gemini response. Address issues before proceeding.
5. **THEN** (and only then): Run tests â†’ Summarize â†’ Commit

**Self-check phrases that should trigger this checkpoint:**
- "I've implemented..." / "I've added..." / "I've modified..."
- "The changes are done" / "Implementation complete"
- "Let me run the tests now" â† STOP! Did you check Gemini threshold?
- "Let me commit these changes" â† STOP! Did you check Gemini threshold?
- **Verification**: Run lints and tests before declaring a task complete.
- DON'T add the implementation documentation to the repositories if not being asked
- Only make changes that are directly requested. Keep solutions simple and focused
- ALWAYS read and understand relevant files before proposing edits. Do not speculate about code you have not inspected.
- After every heuristic / change perform a commit

# Testing (TDD Required)
- Write tests BEFORE implementation
- **Minimum Coverage**: Unit tests (always) + Integration tests (always)
- **E2E Tests**: Only when user-facing features, workflows, or UI exist
- **TDD Process**: Write failing test â†’ Confirm it fails â†’ Minimal code to pass â†’ Confirm pass â†’ Refactor â†’ Repeat

# Code Cleanliness (Boy Scout Rule enforcement)
- Delete unused files, imports, functions, and variables before every commit
- This is automatic enforcement of the Boy Scout Rule; no unused code should ever be committed
- Applies to each heuristic/change as you progress through development

# Long Task Execution

**CRITICAL**: Do not interrupt long-running tasks (builds, tests, deployments, scans) due to context compaction or cleanup operations. Continue until task completion, explicit user interruption, or critical error. Provide progress updates for operations >30s.

# Context Compaction & Skill Persistence

**ðŸš¨ CRITICAL**: When context is compacted or a session resumes, skill state is lost. To maintain consistency:

## On Session Resume / Context Compaction
1. **Identify active work context**: Check what file types are being worked on
2. **Re-invoke relevant skills IMMEDIATELY** before continuing work:
   - Working on `.py` files â†’ `/python`
   - Working on `.sh` files â†’ `/bash`
   - Working on `.go` files â†’ `/golang`
   - Working on `Makefile`/`*.mk` â†’ `/make`
   - Working on `.tf`/`.hcl` â†’ `/terraform`
3. **Re-invoke Gemini review skill** if implementation review was in progress

## Indicators of Context Compaction
- System message about "context compaction" or "summarization"
- Loss of specific implementation details from earlier in conversation
- Sudden shift in conversation continuity

## Self-Check After Compaction
Before continuing any coding task, ask:
- [ ] What file types am I working with?
- [ ] Have I re-loaded the appropriate language skill?
- [ ] Was there a pending Gemini review?

**This ensures code quality standards are maintained even when context window limits are reached.**

# COMMIT
- Don't add the claude signature to the commit
